/** 
**   Name: BlockBreak
**   Author: Snoolas
**   Description: A simple breakout clone with SDL and SDL_ttf in C++.
**   Date: July  2005
**   License: Public Domain. You should have received this file with a LICENSE.txt file. See it
**   for complete details.
**   This file is originally from The Game Programming Wiki: GPWiki.org
**   See README.txt for more information.
**/

#include "USE.hpp"

#define GAMESPEED 20
#define PlayerPaddleY (SCREEN_HEIGHT - (SCREEN_HEIGHT / 10))
#define LIVES 30
#define NUM_OF_BLOCKS 2
#define MAPINDEX 100

/*Routine declarations.*/
void loadmedia();
void mainloop();
void GetInput();
void Think();
void Draw();
void exitvoid();
void NewBall();
void NewLevel();
void UpdateDisplay();

bool brunning; //Whether the main loop should continue.
bool gameovermode; //Whether the GAMEOVER screen should be put on the screen.

int PlayerPaddleX; //The player's X paddle location.
int PlayerPaddleVel; //The player's paddle velocity.
int BallX; //The ball's X location.
int BallY; //The ball's Y location.
int BallXvel; //The ball's X axis velocity.
int BallYvel; //The ball's Y axis velocity.
signed int Lives; //The number of Lives the player has.
int Points; //The number of points the player has.
int levelcount; //The count of levels that the player has won.
bool rightdown; //Whether the right key is down.
bool leftdown; //Whether the left key is down.
int widthoftext; //A global variable used in the rendering of text.
int heightoftext; //A global variable used in the rendering of text.
int YStart; //The Y axis location where the ball should not be spawned above.

SDL_Surface* ball; //The surface holding the ball graphic.
SDL_Surface* paddle; //The surface holding the paddle graphic.
SDL_Surface* gamedialog; //A surface used to render and display text.

struct blockmap //The structure representing a block.
{
  int x; //The block's X axis location.
  int y; //The block's Y axis location.
  int blocktype; //The type of block. 0 is BLOCK0.bmp, 1 is BLOCK1.bmp, so on and so forth.
  signed char hitstogo; //The number of hits that the block can take before breaking. 
  bool inited; //Whether the block was ever initialized.
}; 
blockmap levelmap[MAPINDEX]; //Our levelmap structure that holds every block on the screen's information.

SDL_Surface* blocks[NUM_OF_BLOCKS]; //An array of surfaces holding every block graphic.

nSDL_Font* font; //The font that we will use to render our text.

static unsigned short image_ball[] = {
    0x2a01,0x0004,0x0004,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
};

static unsigned short image_BLOCK0[] = {
    0x2a01,0x0040,0x0010,0x0000,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,
    0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51,0x8c51
};

static unsigned short image_BLOCK1[] = {
    0x2a01,0x0040,0x0010,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
};

static unsigned short image_paddle[] = {
    0x2a01,0x0040,0x0004,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
};

int main(int argc, char *argv[])
{
  /*Initialize the USE codebase.*/
  initUSE();
  
  /*When the application exits, make sure everything is shutdown.*/
  atexit(exitvoid);
  
  /*Load our media, like images and fonts*/
  loadmedia();
  
  /*Set some variables so our mainloop does the right thing*/
  brunning = true;
  gameovermode = true;
  
  /*Enter the main loop, and when we return, exit*/
  mainloop();
  return 0;
}

void loadmedia()
{
  /*Load our media, like images and fonts*/
  ball = nSDL_LoadImage(image_ball);
  paddle = nSDL_LoadImage(image_paddle);
  blocks[0] = nSDL_LoadImage(image_BLOCK0);
  blocks[1] = nSDL_LoadImage(image_BLOCK1);
  
  /*Load the font we will be using*/
  nSDL_LoadFont(NSDL_FONT_TINYTYPE, 255, 255, 255);
}

void mainloop()
{
  long int looptime;
  
  /*Start on our main loop*/
  while (brunning)
  {
    if (!gameovermode){
      
      /*Do everything that needs to be done every frame*/
      GetInput();
      Think();
      Draw();
      
      /*Delay the game according to the gamespeed constant so we don't just eat up all the CPU.*/
      while (SDL_GetTicks() - looptime < GAMESPEED)
      {
      SDL_Delay(10);
      }
      looptime = SDL_GetTicks();
    }
    else {
      if (looptime == 0)
      {
        const char *game_over_str = "GAME OVER. Press N for new game.";
        widthoftext = nSDL_GetStringWidth(font, game_over_str);
        heightoftext = nSDL_GetStringHeight(font, game_over_str);
		gamedialog = SDL_CreateRGBSurface(SDL_SWSURFACE, widthoftext, heightoftext, COLOR_DEPTH, 0, 0, 0, 255);
        	  
		/*Check to see if anything went wrong in rendering the text.*/
        if (gamedialog == 0)
        {
          printf("Unable to render text");
          exit(1);
        }
		nSDL_DrawString(gamedialog, font, 0, 0, game_over_str);
      }
      SDL_FillRect(screen, 0, SDL_MapRGB(screen->format, 0, 0, 0));
      drawimage(gamedialog, 0, 0, widthoftext, heightoftext, screen, 25, 25, 255);
      SDL_Flip(screen);
      
      SDL_Event dialevent;
      while(SDL_PollEvent(&dialevent))
      {
        if (dialevent.type == SDL_KEYDOWN && dialevent.key.keysym.sym == SDLK_n) 
        {
          /*If n is pressed for new game, make the next iteration of the mainloop go into the REAL main loop.*/
          gameovermode = false;
          
          /*Initialize the number of lives based upon our constant.*/
          Lives = LIVES;
          
          /*Initialize our points value*/
          Points = 0;
          
          /*Make sure our old levelcount doesn't carry over*/
          levelcount = 0;
          
          /*Make sure our keystates from last game don't carry over.*/
          rightdown = false;
          leftdown = false;
          
          /*Make sure we have a clean fresh paddle to play with.*/
          PlayerPaddleX = SCREEN_WIDTH / 2;
          PlayerPaddleVel = 0;
          
          /*Give the ball an initial position and velocity.*/
          NewBall();
          
          /*Make a new level*/
          NewLevel();
        }
        /*Check if the user is trying to escape with the escape key.*/
        if (dialevent.type == SDL_KEYDOWN && dialevent.key.keysym.sym == SDLK_ESCAPE) brunning = false;
        /*If SDL is quitting, quit the mainloop.*/
        if (dialevent.type == SDL_QUIT) brunning = false;
      }
      /*Use the same algorithm as above to delay execution and not hog CPU cycles.*/
      while (SDL_GetTicks() - looptime < GAMESPEED)
      {
        SDL_Delay(10);
      }
      looptime = SDL_GetTicks();
    }
  }
}

void GetInput()
{
  /*Quite obviously, an input loop. :)*/
  SDL_Event event;
  while (SDL_PollEvent(&event))
  {
    switch (event.type)
    {
      case SDL_QUIT:                 
      brunning = false;
      break;
      case SDL_KEYDOWN:
      switch (event.key.keysym.sym)
      {
        case SDLK_ESCAPE:
          brunning = false;
          break;
        case SDLK_RIGHT:
          rightdown = true;
          break;
        case SDLK_LEFT:
          leftdown = true;  
          break;
        default: 
          break;
      }
      break;
      case SDL_KEYUP:
      switch (event.key.keysym.sym)
      {
        case SDLK_RIGHT:
        rightdown = false;
        break;
      case SDLK_LEFT:
        leftdown = false;  
        break;        
      default:
        break;
      }
      break;
    } 
  }
}


void NewBall()
{
  UpdateDisplay();
  
  /*Randomly but fairly position the ball on the screen.*/
  BallX = random(0, SCREEN_WIDTH);
  BallY = random(YStart, PlayerPaddleY - (int)floor((double)SCREEN_WIDTH / 10)); 
	
  /*Set the ball's velocity.*/
  BallXvel = random(-5, 5);
  BallYvel = random(2, 5);  
}

void NewLevel()
{
  /*This void loads up a fresh new level based upon what blocks we have loaded and what level it is.*/
  
  int CurY = 0; /*The current Y axis location to place new blocks at.*/
  int CurX = 0; /*The current X axis location to place new blocks at.*/
  int CurLevelIndex = 0; /*The current block in the levelmap array that we are working with.*/
  
  /*Make sure all of our blocks are set as not being initialized.*/
  for (int i = 0; i < MAPINDEX; i++)
  {
    levelmap[i].inited = false;
  }
  CurY = gamedialog->h;
  
  /*Generate our level!
  For every level the player has won, for every block that we have loaded, make a row of that block.*/
  
  for (int a = 0; a <= levelcount; a++)
  {
    for (int b = NUM_OF_BLOCKS - 1; b >= 0; b--)
    {
      /*Center the blocks on the screen if they don't evenly fit into the screen's width.*/
      CurX = static_cast<int>(floor(static_cast<double>((SCREEN_WIDTH % blocks[b]->w) / 2)));
      for (int c = 0; c <= static_cast<int>(floor(static_cast<double>((SCREEN_WIDTH - blocks[b]->w) / blocks[b]->w))); c++)
      {
        //if (c=0) printf("C-Max: %d", static_cast<int>(floor(static_cast<double>((SCREEN_WIDTH - blocks[b]->w) / blocks[b]->w))));
	/*Make sure our levelmap arrray is big enough for the new level. If it isn't, panic!*/
        if (CurLevelIndex > MAPINDEX)
        {
          printf("MAPINDEX not high enough");
          exit(1);
        }
        
        /*Fill our current entry in the levelmap array with the proper information.*/
        levelmap[CurLevelIndex].x = CurX;
        levelmap[CurLevelIndex].y = CurY;
        levelmap[CurLevelIndex].blocktype = b;
        levelmap[CurLevelIndex].hitstogo = b + 1;
        levelmap[CurLevelIndex].inited = true;
        
        /*Increment the CurLevelIndex variable so on the next block we populate with information will be the next index in the array.*/
        CurLevelIndex++;
        
        /*Up the current X axis location to accomodate for the next block.*/
        CurX += blocks[b]->w;
      }
      /*If the moment is right, up the current Y axis location to accomodate for the next row of blocks.*/
      if (b < NUM_OF_BLOCKS) CurY += blocks[b]->h;
        
      /*Blank out the X axis location because we are starting a new row.*/
      CurX = 0;
    }
  }
  /*Save the final Y location in a variable so that we know where the highest is that we can spawn a ball.*/
  YStart = CurY + blocks[0]->h;
  
  /*Because the game is so darn hard, give the player an extra ten lives.*/
  Lives += 10;
  
  /*Spawn a new ball. We don't want the ball to be in the middle of a new block we just made...*/
  NewBall();
}

void Think()
{
  /*Move the Player's paddle according to how they have their buttons pushed.*/
  if (rightdown) PlayerPaddleVel += 1;
  if (leftdown) PlayerPaddleVel -= 1;
  if (!rightdown && PlayerPaddleVel > 0) PlayerPaddleVel -= 1;
  if (!leftdown && PlayerPaddleVel < 0) PlayerPaddleVel += 1;

  /*Make sure the player's paddle velocity and position wouldn't put the paddle through the wall and if that goes well, move the paddle, if not,
    bounce the paddle off of the wall.*/  
  if ((PlayerPaddleX + PlayerPaddleVel <= SCREEN_WIDTH - 64) && (PlayerPaddleX + PlayerPaddleVel >= 0))
  {
    PlayerPaddleX += PlayerPaddleVel;
  }
  else
  {
    PlayerPaddleVel = (PlayerPaddleVel * -1) / 2;
  }

  
  /*Check if the ball is intersecting the player's paddle and if so, adjust the ball's velocities according to how it was moving in relation to the paddle.*/
  if (((BallX >= PlayerPaddleX) && ((BallX + 4) <= (PlayerPaddleX + 64))) && ((BallY >= PlayerPaddleY) && (BallY <= PlayerPaddleY + 4)))
  {
    if (PlayerPaddleVel == 0)
    {
      BallYvel *= -1;
    }
    else 
    {
      if ((PlayerPaddleVel < 0 && BallXvel < 0) || (PlayerPaddleVel > 0 && BallXvel > 0))
      {
        BallYvel *= -1;
        BallXvel *= 2;
      }
      else 
      {
        BallYvel = (BallYvel *-1) + (PlayerPaddleVel / 2);
      }
    }
  }
  
  /*First check if the ball location and ball velocity suggest that the ball needs to be bounced and if so, do it, but if not, continue moving the ball according to the velocity.*/
  if ((BallX + BallXvel) > 0 && (BallX + BallXvel) <= SCREEN_WIDTH)
  {
    BallX += BallXvel;
  }
  else
  {
    BallXvel *= -1;
  }

  /*This is like the section above, but it only checks to see if it is going offscreen and if not it updates the ball's location.*/
  if ((BallY + BallYvel) > 0 && (BallY + BallYvel) <= SCREEN_HEIGHT)
  {
    BallY += BallYvel;
  }

  /*If the ball is moving offscreen in certain dimensions, do what needs to be done to it.*/
  if (BallY + BallYvel <= 0)
  {
    BallYvel *= -1;
  }
  if (BallY + BallYvel >= SCREEN_HEIGHT)
  {
    Lives -= 1;
    NewBall();
  }

  /*The somewhat intimidating block collison detection code.*/  
  /*Loop through all of our blocks and if they exist then check if the ball is intersecting them.*/
  bool anyleft = false; /*A boolean representing whether there are any blocks left on the screen.*/
  for (int i = 0; i < MAPINDEX; i++)
  {
    if (levelmap[i].inited && levelmap[i].hitstogo > 0)
    {
      int blocktype = levelmap[i].blocktype; //To keep our following line a little shorter...
      int blockx = levelmap[i].x;
      int blocky = levelmap[i].y;
      int blockw = blocks[blocktype]->w;
      int blockh = blocks[blocktype]->h;
      
      /*Set the anyleft variable to true, because if we are here, then there are blocks still on the screen.*/
      anyleft = true;
      //printf("Anyleft = true: i: %d \n", i);//, Inited: %u, HTG: %d\n", i);
      
      if ((BallX >= blockx && BallX + 4 <= blockx + blockw) && (BallY >= blocky && BallY + 4 <= blocky + blockh))
      {
        /*Decrement the hits to go counter because we hit the block*/
        levelmap[i].hitstogo--;
        
        /*If we destroyed the block then add the according number of points and update the display.*/
        if (levelmap[i].hitstogo == 0)
        {
          Points += (blocktype + 1) * 10;
          UpdateDisplay();
        }
        
        /*Invert the Ball's velocity variable to bounce it. This will always bounce the ball a certain way, making it somewhat of a dirty hack. If the ball hit the block on the side 
        instead of the top or bottom, this would be awfully unrealistic, sometimes plowing through the whole row. We'll just call it a "feature!" :) */
        BallYvel *= -1;
      }
    }
  }
  
  /*If anyleft is still false, it means that there are no blocks left, so we need to go to the next level*/
  if (anyleft == false)
  {
    levelcount++;
    NewLevel();
    UpdateDisplay();
  }    
}

void Draw()
{
  /*First fill the screen with white so our black images will show up and then draw our images to the screen surface in the correct locations and finally flip the 
  screen surface to the actual screen.*/
  SDL_FillRect(screen, 0, SDL_MapRGB(screen->format, 255, 255, 255));
  drawimage(gamedialog, 0, 0, widthoftext, heightoftext, screen, 0, 0, 255);
  drawimage(paddle, 0, 0, 64, 4, screen, PlayerPaddleX, PlayerPaddleY, 255);
  drawimage(ball, 0, 0, 4, 4, screen, BallX, BallY, 255);
  
  /*Loop through all of our blocks and if they should still be there, then draw them.*/
  for (int x = 0; x < MAPINDEX; x++)
  {
    if (levelmap[x].inited && levelmap[x].hitstogo > 0)
    {
      int blocktype = levelmap[x].blocktype;
      drawimage(blocks[blocktype], 0, 0, blocks[blocktype]->w, blocks[blocktype]->h, screen, levelmap[x].x, levelmap[x].y, 255);
    }
  }  
  SDL_Flip(screen);  
}

void UpdateDisplay()
{
  /*Write our score string to the buffer.*/
  char scoretext[40];
  sprintf(scoretext, "Lives: %d, Points: %d, Level: %d", Lives, Points, levelcount + 1);
  
  /*Render our score text buffer to the gamedialog surface.*/
  widthoftext = nSDL_GetStringWidth(font, scoretext);
  if (widthoftext > 320)
	widthoftext = 320; // work around nSDL bug
  heightoftext = nSDL_GetStringHeight(font, scoretext);
  gamedialog = SDL_CreateRGBSurface(SDL_SWSURFACE, widthoftext, heightoftext, COLOR_DEPTH, 255, 255, 255, 255);

  /*Check to see if anything went wrong in rendering the text.*/
  if (gamedialog == 0)
  {
    printf("Unable to render text");
    exit(1);
  }
  nSDL_DrawString(gamedialog, font, 0, 0, scoretext);
  
  /*Check to see if either player or computer has won and if so enter game over mode so the next iteration of the mainloop will be drawing the game over message on the screen.*/
  if (Lives < 0)
  {
    gameovermode = true;
  }
}

void exitvoid()
{
  /*Destroy our libraries and media so we don't leave bunches of junk in memory.*/
  SDL_FreeSurface(screen);
  SDL_FreeSurface(paddle);
  SDL_FreeSurface(ball);
  SDL_FreeSurface(gamedialog);
  
  for (int x = 0; x < NUM_OF_BLOCKS; x++)
  {
    SDL_FreeSurface(blocks[x]);
  }    
  
  nSDL_FreeFont(font);
  
  SDL_Quit();
}  
