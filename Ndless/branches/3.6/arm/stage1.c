/****************************************************************************
 * Stage 1 of the installation.
 * Loads the installer.
 * Error checking is disabled due to the size constraint of ndless_installer.
 *
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is Ndless code.
 *
 * The Initial Developer of the Original Code is Fabian Vogt.
 * Portions created by the Initial Developer are Copyright (C) 2013
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s): Excale, Olivier ARMAND <olivier.calc@gmail.com>.
 *                 
 ****************************************************************************/

#include "ndless.h"
#include <stdint.h>

// As expected by the patch headers generated by MakeHotRebootPtch
#define PATCH_CLRW(A)   *(uint32_t *)(A) = 0
#define PATCH_WW(A,B)   *(uint32_t *)(A) = (B)
#define PATCH_CLRZ(A,B)  PATCH_SETZ((A), (B), 0x0)
#define PATCH_SETZ(A,B,C) memset((void *)(A), (C), (B)-(A))

static int8_t model = -1; // model&1: CAS bit; >1 => screen has colors

static void write_i2c(uint8_t client, uint8_t addr, uint8_t value) {
    PATCH_WW(0x9005006c, 0); //Disable I2C
    PATCH_WW(0x90050004, client); //Set target address
    PATCH_WW(0x9005006c, 1); //Enable I2C
    volatile uint32_t *status = (uint32_t*) 0x90050070;
    PATCH_WW(0x90050010, addr);
    while(*status & 1); //Wait until transmitted
    PATCH_WW(0x90050010, value);
    while(*status & 1); //Wait until transmitted
}

static void write_touchpad(uint16_t port, uint8_t value) {
    write_i2c(0x20, 0xFF, port >> 8);
    write_i2c(0x20, port & 0xFF, value);
}

// OS-specific
static unsigned const ndless_inst_resident_hook_addrs[] = {0, 0, 0, 0x10012370};

// Install the resident part.
HOOK_DEFINE(s1_startup_hook) {
	ut_read_os_version_index();
	ints_setup_handlers();
	struct stat res_stat;
	const char *res_path = NDLESS_DIR "/ndless_resources.tns";
	FILE *res_file = fopen(res_path, "rb");
	if (!res_file) {
		//show_msgbox("Ndless", "You have forgotten to transfer 'ndless_resources'. Ndless won't be installed.");
		goto s1_startup_hook_return;
	}
	stat(res_path, &res_stat);
	char *core = malloc(res_stat.st_size);
	fread(core, res_stat.st_size, 1, res_file);
	fclose(res_file);
	char *res_params = NULL; // Dummy filename to tell the installer we are booting or installing
	clear_cache();
	((void (*)(int argc, void* argv))(char*)core + sizeof(PRGMSIG))(1, &res_params); // Run the core installation
s1_startup_hook_return:
	HOOK_RESTORE_RETURN(s1_startup_hook);
}

int main(void) {
	ut_disable_watchdog();
	ut_read_os_version_index();
	ints_setup_handlers();
	
    //Disable the watchdog on CX that may trigger a reset
    *(volatile unsigned*)0x90060C00 = 0x1ACCE551; // enable write access to all other watchdog registers
    *(volatile unsigned*)0x90060008 = 0;          // disable reset, counter and interrupt
    *(volatile unsigned*)0x90060C00 = 0;          // disable write access to all other watchdog registers
    
    switch (*((volatile uint32_t *)0x10000020))
    {
        case 0x10375BB0:    // TI-Nspire-3.6.0.546/phoenix.raw
            model = 0;
        break;
        case 0x103765F0:    // TI-NspireCAS-3.6.0.546/phoenix.raw
            model = 1;
        break; 
        case 0x10375620:    // TI-NspireCX-3.6.0.546/phoenix.raw
            model = 2;
        break;
        case 0x10376090:    // TI-NspireCXCAS-3.6.0.546/phoenix.raw
            model = 3;
        break;
        default:
            //"Fun fact: trying to nstall Ndless 3.6.546 without having OS 3.6.546 is NOT a good idea. I am now going to drain your battery." (cannot even print it because we do not know if the screen has colors)
            while (1) {}
        break;
    }
	
    //Reset all timers and their IRQ flags
    if (model > 1) {
        PATCH_WW(0x90010008, 0);
        PATCH_WW(0x90010008, 0);
        PATCH_WW(0x9001000C, 1);
        PATCH_WW(0x90010028, 0);
        PATCH_WW(0x9001002C, 1);
        PATCH_WW(0x900C0008, 0);
        PATCH_WW(0x900C000C, 1);
        PATCH_WW(0x900C0028, 0);
        PATCH_WW(0x900C002C, 1);
        PATCH_WW(0x900D0008, 0);
        PATCH_WW(0x900D000C, 1);
        PATCH_WW(0x900D0028, 0);
        PATCH_WW(0x900D002c, 1);
    } //Causes the EMU(!) to be slower than TI's schedule to fix math bugs on CAS OS.
    
    //Disable all interrupts
    if (model < 2) {
        PATCH_WW(0xDC000008, 0xFFFFFFFF);
    } else {
        PATCH_WW(0xDC000014, 0xFFFFFFFF);
    }
	
    if (model > 1) {
        //Reset touchpad
        write_touchpad(0x0004, 0x01);
        //Disable I2C IRQ
        PATCH_WW(0x90050030, 0);
        //Disable I2C
        PATCH_WW(0x9005006C, 0);
    }
    //Disable RTC IRQ
    PATCH_WW(0x9009000C, 1);

    //Disable keypad and touchpad IRQs
    PATCH_WW(0x900E000C, 0);
    PATCH_WW(0x900E0040, 0);

	// Reset OS global variables to their initial values
	#include "hrpatches-os-cascx-3.6.0.h"
	// Reset internal RAM state, else instable without USB plugged-in
	#include "hrpatches-internal-ram-cascx-3.6.0.h"
	
	HOOK_INSTALL(ndless_inst_resident_hook_addrs[ut_os_version_index], s1_startup_hook);
	
	clear_cache();
	((void(*)(void))0x10000000)(); // Hot-reboot the OS
	__builtin_unreachable();
	return 0;
}
